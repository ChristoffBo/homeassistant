import os, json, time, asyncio, requests, websockets, schedule, datetime, random

# -----------------------------
# Config from environment
# -----------------------------
BOT_NAME = os.getenv("BOT_NAME", "Jarvis")
BOT_ICON = os.getenv("BOT_ICON", "ü§ñ")
GOTIFY_URL = os.getenv("GOTIFY_URL")
CLIENT_TOKEN = os.getenv("GOTIFY_CLIENT_TOKEN")
APP_TOKEN = os.getenv("GOTIFY_APP_TOKEN")
APP_NAME = os.getenv("JARVIS_APP_NAME", "Jarvis")

# Retention / Cleanup
RETENTION_HOURS = int(os.getenv("RETENTION_HOURS", "24"))

# Radarr
RADARR_ENABLED = os.getenv("RADARR_ENABLED", "false").lower() in ("1","true","yes")
RADARR_URL = os.getenv("RADARR_URL", "")
RADARR_API_KEY = os.getenv("RADARR_API_KEY", "")

# Sonarr
SONARR_ENABLED = os.getenv("SONARR_ENABLED", "false").lower() in ("1","true","yes")
SONARR_URL = os.getenv("SONARR_URL", "")
SONARR_API_KEY = os.getenv("SONARR_API_KEY", "")

# Weather (MET Norway API)
WEATHER_ENABLED = os.getenv("WEATHER_ENABLED", "false").lower() in ("1","true","yes")
WEATHER_LAT = os.getenv("WEATHER_LAT", "")
WEATHER_LON = os.getenv("WEATHER_LON", "")

jarvis_app_id = None
radarr_cache, sonarr_cache = {}, {}

# -----------------------------
# Gotify Messaging
# -----------------------------
def send_message(title, message, priority=5):
    url = f"{GOTIFY_URL}/message?token={APP_TOKEN}"
    data = {"title": f"{BOT_ICON} {BOT_NAME}: {title}", "message": message, "priority": priority}
    try:
        r = requests.post(url, json=data, timeout=5)
        r.raise_for_status()
        return True
    except Exception as e:
        print(f"[{BOT_NAME}] Send failed: {e}")
        return False

def delete_message(msg_id):
    if not msg_id: return False
    try:
        url = f"{GOTIFY_URL}/message/{msg_id}?token={CLIENT_TOKEN}"
        r = requests.delete(url, timeout=5)
        return r.status_code == 200
    except: return False

# -----------------------------
# Resolve Jarvis App ID
# -----------------------------
def resolve_app_id():
    global jarvis_app_id
    try:
        url = f"{GOTIFY_URL}/application?token={CLIENT_TOKEN}"
        r = requests.get(url, timeout=5)
        r.raise_for_status()
        for app in r.json():
            if app.get("name") == APP_NAME:
                jarvis_app_id = app.get("id")
                print(f"[{BOT_NAME}] Resolved {APP_NAME} ‚Üí id {jarvis_app_id}")
                return
    except Exception as e:
        print(f"[{BOT_NAME}] Failed to resolve app id: {e}")

# -----------------------------
# Beautify
# -----------------------------
def beautify_message(raw):
    lower = raw.lower()
    prefix = "üí°"
    if "error" in lower: prefix = "üíÄ"
    elif "success" in lower or "completed" in lower: prefix = "‚úÖ"
    elif "warning" in lower: prefix = "‚ö†Ô∏è"
    elif "start" in lower: prefix = "üöÄ"

    closings = [
        f"{BOT_ICON} Yours truly, {BOT_NAME}",
        f"‚ú® Processed intelligently by {BOT_NAME}",
        f"üìä Insight provided by {BOT_NAME}",
        f"üìö Report generated by {BOT_NAME}",
        f"üåê Analysis complete ‚Äî {BOT_NAME} signing off",
    ]
    return f"{prefix} {raw}\n\n{random.choice(closings)}"

# -----------------------------
# Cleanup
# -----------------------------
def cleanup_non_jarvis():
    if not jarvis_app_id: return
    try:
        url = f"{GOTIFY_URL}/message?token={CLIENT_TOKEN}"
        msgs = requests.get(url, timeout=5).json().get("messages", [])
        for msg in msgs:
            if msg.get("appid") != jarvis_app_id:
                delete_message(msg["id"])
    except: pass

def cleanup_old_jarvis():
    cutoff = time.time() - (12*3600)
    try:
        url = f"{GOTIFY_URL}/message?token={CLIENT_TOKEN}"
        msgs = requests.get(url, timeout=5).json().get("messages", [])
        for msg in msgs:
            ts = datetime.datetime.fromisoformat(msg["date"].replace("Z","+00:00")).timestamp()
            if ts < cutoff and msg.get("appid") == jarvis_app_id:
                delete_message(msg["id"])
    except: pass

# -----------------------------
# Radarr / Sonarr
# -----------------------------
def get_radarr_movies():
    global radarr_cache
    if not RADARR_ENABLED: return []
    try:
        url = f"{RADARR_URL.rstrip('/')}/api/v3/movie?apikey={RADARR_API_KEY}"
        data = requests.get(url, timeout=10).json()
        radarr_cache = {m["id"]: m for m in data}
        return data
    except: return list(radarr_cache.values())

def get_sonarr_series():
    global sonarr_cache
    if not SONARR_ENABLED: return []
    try:
        url = f"{SONARR_URL.rstrip('/')}/api/v3/series?apikey={SONARR_API_KEY}"
        data = requests.get(url, timeout=10).json()
        sonarr_cache = {s["id"]: s for s in data}
        return data
    except: return list(sonarr_cache.values())

def get_upcoming_movies(days=7):
    try:
        start = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d")
        end = (datetime.datetime.now(datetime.timezone.utc)+datetime.timedelta(days=days)).strftime("%Y-%m-%d")
        url = f"{RADARR_URL.rstrip('/')}/api/v3/calendar?apikey={RADARR_API_KEY}&start={start}&end={end}"
        return requests.get(url, timeout=10).json()
    except: return []

def get_upcoming_episodes(days=7):
    try:
        start = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d")
        end = (datetime.datetime.now(datetime.timezone.utc)+datetime.timedelta(days=days)).strftime("%Y-%m-%d")
        url = f"{SONARR_URL.rstrip('/')}/api/v3/calendar?apikey={SONARR_API_KEY}&start={start}&end={end}"
        return requests.get(url, timeout=10).json()
    except: return []

# -----------------------------
# Weather
# -----------------------------
def get_weather():
    if not WEATHER_ENABLED: return "Weather disabled."
    try:
        url = f"https://api.met.no/weatherapi/locationforecast/2.0/compact?lat={WEATHER_LAT}&lon={WEATHER_LON}"
        r = requests.get(url, headers={"User-Agent":"JarvisBot/1.0"}, timeout=10).json()
        d = r["properties"]["timeseries"][0]["data"]["instant"]["details"]
        return f"üå§ {d['air_temperature']}¬∞C, wind {d['wind_speed']} km/h"
    except Exception as e:
        return f"Weather error: {e}"

# -----------------------------
# Command Handler
# -----------------------------
def handle_command(msg):
    q = msg.lower()

    # Counts
    if "movie count" in q or "how many movies" in q:
        return f"üé¨ {len(get_radarr_movies())} movies in collection."
    if "series count" in q or "how many series" in q:
        return f"üì∫ {len(get_sonarr_series())} series in collection."

    # Movies longest/shortest
    if "longest movie" in q:
        m = max(get_radarr_movies(), key=lambda x:x.get("runtime",0), default=None)
        return f"üé¨ Longest movie: {m['title']} ({m.get('runtime',0)} mins)" if m else "No movies."
    if "shortest movie" in q:
        m = min(get_radarr_movies(), key=lambda x:x.get("runtime",9999), default=None)
        return f"üé¨ Shortest movie: {m['title']} ({m.get('runtime',0)} mins)" if m else "No movies."

    # Series largest/longest
    if "largest series" in q:
        s = max(get_sonarr_series(), key=lambda x:x.get("episodeCount",0), default=None)
        return f"üì∫ Largest series: {s['title']} ({s.get('episodeCount',0)} episodes)" if s else "No series."
    if "longest series" in q:
        s = max(get_sonarr_series(), key=lambda x:x.get("seasonCount",0), default=None)
        return f"üì∫ Longest series: {s['title']} ({s.get('seasonCount',0)} seasons)" if s else "No series."

    # Upcoming
    if "upcoming movie" in q:
        items = get_upcoming_movies()
        if not items: return "üé¨ No upcoming movies."
        return "üé¨ Upcoming movies:\n" + "\n".join([f"‚Ä¢ {m['title']} ({m['inCinemas'][:10]})" for m in items[:5]])
    if "upcoming series" in q or "upcoming show" in q:
        items = get_upcoming_episodes()
        if not items: return "üì∫ No upcoming episodes."
        return "üì∫ Upcoming episodes:\n" + "\n".join([f"‚Ä¢ {e['series']['title']} - S{e['seasonNumber']}E{e['episodeNumber']} ({e['airDate']})" for e in items[:5] if e.get('series')])

    # Weather
    if "weather" in q:
        return get_weather()

    # Help
    if "help" in q:
        return (
            "ü§ñ Commands:\n"
            "- movie count / series count\n"
            "- longest movie / shortest movie\n"
            "- largest series / longest series\n"
            "- upcoming movies / upcoming series\n"
            "- weather"
        )

    return f"ü§ñ Unknown. Try '{BOT_NAME} help'."

# -----------------------------
# Scheduler
# -----------------------------
def run_scheduler():
    schedule.every(5).seconds.do(cleanup_non_jarvis)
    schedule.every(12).hours.do(cleanup_old_jarvis)
    while True:
        schedule.run_pending()
        time.sleep(1)

# -----------------------------
# Listener
# -----------------------------
async def listen():
    ws_url = GOTIFY_URL.replace("http://","ws://").replace("https://","wss://") + f"/stream?token={CLIENT_TOKEN}"
    async with websockets.connect(ws_url, ping_interval=30, ping_timeout=10) as ws:
        async for raw in ws:
            data = json.loads(raw)
            mid, appid, title, message = data["id"], data["appid"], data["title"], data["message"]
            if appid == jarvis_app_id: continue
            if BOT_NAME.lower() in (title+message).lower():
                resp = handle_command(message)
                send_message("Response", beautify_message(resp))
                delete_message(mid)
            else:
                send_message(title, beautify_message(message))
                delete_message(mid)

# -----------------------------
# Main
# -----------------------------
if __name__ == "__main__":
    resolve_app_id()
    send_message("Startup", f"üöÄ {BOT_NAME} is online.", 5)
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.create_task(listen())
    loop.run_in_executor(None, run_scheduler)
    loop.run_forever()
