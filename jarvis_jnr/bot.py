import os, json, time, asyncio, requests, websockets, schedule, datetime, random

# -----------------------------
# Config from environment
# -----------------------------
BOT_NAME = os.getenv("BOT_NAME", "Jarvis")
BOT_ICON = os.getenv("BOT_ICON", "ü§ñ")
GOTIFY_URL = os.getenv("GOTIFY_URL")
CLIENT_TOKEN = os.getenv("GOTIFY_CLIENT_TOKEN")
APP_TOKEN = os.getenv("APP_TOKEN")
APP_NAME = os.getenv("APP_NAME", "Jarvis")

# Radarr/Sonarr
RADARR_URL = os.getenv("radarr_url")
RADARR_KEY = os.getenv("radarr_api_key")
SONARR_URL = os.getenv("sonarr_url")
SONARR_KEY = os.getenv("sonarr_api_key")

# Weather
WEATHER_CITY = os.getenv("weather_city", "Johannesburg")
WEATHER_LAT = os.getenv("weather_lat", "")
WEATHER_LON = os.getenv("weather_lon", "")

RETENTION_HOURS = int(os.getenv("RETENTION_HOURS", "12"))
jarvis_app_id = None

# In-memory caches
cache_movies = None
cache_series = None
cache_expiry = 0

# -----------------------------
# Gotify Helpers
# -----------------------------
def send_message(title, message, priority=5):
    url = f"{GOTIFY_URL}/message?token={APP_TOKEN}"
    data = {"title": f"{BOT_ICON} {BOT_NAME}: {title}", "message": message, "priority": priority}
    try:
        requests.post(url, json=data, timeout=5)
    except Exception as e:
        print("Send error:", e)

def delete_message(mid):
    try:
        url = f"{GOTIFY_URL}/message/{mid}?token={CLIENT_TOKEN}"
        requests.delete(url, timeout=5)
    except Exception as e:
        print("Delete error:", e)

# -----------------------------
# Beautify
# -----------------------------
def beautify_message(title, raw):
    closings = [
        f"{BOT_ICON} Yours truly, {BOT_NAME}",
        f"‚ú® Insight provided by {BOT_NAME}",
        f"üåç Analysis complete ‚Äî {BOT_NAME} signing off",
        f"ü§ñ Processed intelligently by {BOT_NAME}",
        f"üìä Report generated by {BOT_NAME}"
    ]
    return f"üí° {raw}\n\n{random.choice(closings)}"

# -----------------------------
# Cleanup
# -----------------------------
def cleanup_messages():
    try:
        url = f"{GOTIFY_URL}/message?token={CLIENT_TOKEN}"
        msgs = requests.get(url, timeout=5).json().get("messages", [])
        cutoff = time.time() - (RETENTION_HOURS * 3600)
        for m in msgs:
            ts = datetime.datetime.fromisoformat(m["date"].replace("Z","+00:00")).timestamp()
            if ts < cutoff and m.get("id") and BOT_NAME not in m.get("title",""):
                delete_message(m["id"])
    except Exception as e:
        print("Cleanup error:", e)

# -----------------------------
# Radarr / Sonarr
# -----------------------------
def get_upcoming_movies(days=7):
    try:
        global cache_movies, cache_expiry
        now = time.time()
        if cache_movies and now < cache_expiry:
            return cache_movies
        start = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d")
        end = (datetime.datetime.now(datetime.timezone.utc)+datetime.timedelta(days=days)).strftime("%Y-%m-%d")
        url = f"{RADARR_URL}/api/v3/calendar?start={start}&end={end}&token={RADARR_KEY}"
        cache_movies = requests.get(url, timeout=10).json()
        cache_expiry = now + 60
        return cache_movies
    except Exception as e:
        print("Radarr error:", e)
        return []

def get_upcoming_episodes(days=7):
    try:
        global cache_series, cache_expiry
        now = time.time()
        if cache_series and now < cache_expiry:
            return cache_series
        start = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d")
        end = (datetime.datetime.now(datetime.timezone.utc)+datetime.timedelta(days=days)).strftime("%Y-%m-%d")
        url = f"{SONARR_URL}/api/v3/calendar?start={start}&end={end}&apikey={SONARR_KEY}"
        cache_series = requests.get(url, timeout=10).json()
        cache_expiry = now + 60
        return cache_series
    except Exception as e:
        print("Sonarr error:", e)
        return []

def get_movie_count():
    try:
        url = f"{RADARR_URL}/api/v3/movie?apikey={RADARR_KEY}"
        return len(requests.get(url, timeout=10).json())
    except: return 0

def get_series_count():
    try:
        url = f"{SONARR_URL}/api/v3/series?apikey={SONARR_KEY}"
        return len(requests.get(url, timeout=10).json())
    except: return 0

def get_longest_movie():
    try:
        url = f"{RADARR_URL}/api/v3/movie?apikey={RADARR_KEY}"
        movies = requests.get(url, timeout=10).json()
        m = max(movies, key=lambda x: x.get("runtime",0))
        return f"üé¨ Longest movie: {m.get('title')} ({m.get('runtime')} mins)"
    except: return "üé¨ Could not fetch longest movie."

def get_longest_series():
    try:
        url = f"{SONARR_URL}/api/v3/series?apikey={SONARR_KEY}"
        shows = requests.get(url, timeout=10).json()
        s = max(shows, key=lambda x: x.get("episodeCount",0))
        return f"üì∫ Longest series: {s.get('title')} ({s.get('episodeCount')} episodes)"
    except: return "üì∫ Could not fetch longest series."

# -----------------------------
# Weather (via wttr.in)
# -----------------------------
def get_weather():
    try:
        if WEATHER_LAT and WEATHER_LON:
            url = f"https://wttr.in/{WEATHER_LAT},{WEATHER_LON}?format=j1"
        else:
            url = f"https://wttr.in/{WEATHER_CITY}?format=j1"
        data = requests.get(url, timeout=10).json()
        cur = data["current_condition"][0]
        return f"üå§ {WEATHER_CITY}: {cur['temp_C']}¬∞C, wind {cur['windspeedKmph']} km/h"
    except:
        return "üå§ Weather unavailable right now."

# -----------------------------
# Handle Commands
# -----------------------------
def handle_command(msg):
    q = msg.lower()

    if "weather" in q: return get_weather()
    if "movie count" in q: return f"üé¨ You have {get_movie_count()} movies."
    if "series count" in q: return f"üì∫ You have {get_series_count()} series."
    if "longest movie" in q: return get_longest_movie()
    if "longest series" in q: return get_longest_series()

    if "upcoming movie" in q:
        um = get_upcoming_movies()
        if not um: return "üé¨ No upcoming movies this week."
        lines = [f"{m.get('title','Unknown')} ({m.get('physicalRelease','N/A')})" for m in um[:5]]
        return "üé¨ Upcoming movies:\n" + "\n".join(lines)

    if "upcoming series" in q or "upcoming show" in q:
        us = get_upcoming_episodes()
        if not us: return "üì∫ No upcoming episodes this week."
        lines = []
        for e in us[:5]:
            title = e.get("series", {}).get("title", "Unknown Show")
            season, epnum = e.get("seasonNumber"), e.get("episodeNumber")
            airdate = e.get("airDate","N/A")
            lines.append(f"{title} S{season}E{epnum} ({airdate})")
        return "üì∫ Upcoming episodes:\n" + "\n".join(lines)

    return None

# -----------------------------
# Websocket Listener
# -----------------------------
async def listen():
    ws_url = GOTIFY_URL.replace("http://","ws://").replace("https://","wss://")+f"/stream?token={CLIENT_TOKEN}"
    async with websockets.connect(ws_url) as ws:
        async for msg in ws:
            data = json.loads(msg)
            mid, message = data.get("id"), data.get("message","")
            if not mid: continue
            resp = handle_command(message)
            if resp:
                send_message("Response", beautify_message("Response", resp))
                delete_message(mid)

# -----------------------------
# Main
# -----------------------------
if __name__ == "__main__":
    print(f"[{BOT_NAME}] Starting add-on...")

    # Random startup greeting
    startup_msg = random.choice([
        f"Good Day, I am {BOT_NAME}, ready to assist.",
        f"Greetings, {BOT_NAME} is now online and standing by.",
        f"üöÄ {BOT_NAME} systems initialized and operational.",
        f"{BOT_NAME} reporting for duty.",
        f"ü§ñ Hello, {BOT_NAME} at your service."
    ])
    send_message("Startup", beautify_message("Startup", startup_msg), priority=5)

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.create_task(listen())
    schedule.every(5).seconds.do(cleanup_messages)
    while True:
        schedule.run_pending()
        time.sleep(1)
