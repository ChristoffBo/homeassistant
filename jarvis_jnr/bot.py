import os, json, time, asyncio, requests, websockets, schedule, datetime, random, difflib

# -----------------------------
# Config from environment
# -----------------------------
BOT_NAME = os.getenv("BOT_NAME", "Jarvis")
BOT_ICON = os.getenv("BOT_ICON", "ü§ñ")
GOTIFY_URL = os.getenv("GOTIFY_URL")
CLIENT_TOKEN = os.getenv("GOTIFY_CLIENT_TOKEN")
APP_TOKEN = os.getenv("GOTIFY_APP_TOKEN")
APP_NAME = os.getenv("JARVIS_APP_NAME", "Jarvis")

# Retention / Cleanup
RETENTION_HOURS = int(os.getenv("RETENTION_HOURS", "24"))

# Radarr
RADARR_ENABLED = os.getenv("RADARR_ENABLED", "false").lower() in ("1", "true", "yes")
RADARR_URL = os.getenv("RADARR_URL", "")
RADARR_API_KEY = os.getenv("RADARR_API_KEY", "")

# Sonarr
SONARR_ENABLED = os.getenv("SONARR_ENABLED", "false").lower() in ("1", "true", "yes")
SONARR_URL = os.getenv("SONARR_URL", "")
SONARR_API_KEY = os.getenv("SONARR_API_KEY", "")

# Weather (Norwegian Met API ‚Äì no API key needed)
WEATHER_ENABLED = os.getenv("WEATHER_ENABLED", "false").lower() in ("1", "true", "yes")
WEATHER_LAT = os.getenv("WEATHER_LAT", "")
WEATHER_LON = os.getenv("WEATHER_LON", "")

jarvis_app_id = None
radarr_cache, sonarr_cache = {}, {}

# -----------------------------
# Send message
# -----------------------------
def send_message(title, message, priority=5):
    url = f"{GOTIFY_URL}/message?token={APP_TOKEN}"
    data = {
        "title": f"{BOT_ICON} {BOT_NAME}: {title}",
        "message": message,
        "priority": priority,
    }
    try:
        r = requests.post(url, json=data, timeout=5)
        r.raise_for_status()
        return True
    except Exception as e:
        print(f"[{BOT_NAME}] Send failed: {e}")
        return False

# -----------------------------
# Delete message
# -----------------------------
def delete_message(msg_id):
    if not msg_id: return False
    try:
        url = f"{GOTIFY_URL}/message/{msg_id}?token={CLIENT_TOKEN}"
        r = requests.delete(url, timeout=5)
        return r.status_code == 200
    except: return False

# -----------------------------
# Beautify
# -----------------------------
def beautify_message(raw):
    lower = raw.lower()
    prefix = "üí°"
    if "error" in lower: prefix = "üíÄ"
    elif "success" in lower or "completed" in lower: prefix = "‚úÖ"
    elif "warning" in lower: prefix = "‚ö†Ô∏è"
    elif "start" in lower: prefix = "üöÄ"

    closings = [
        f"{BOT_ICON} Yours truly, {BOT_NAME}",
        f"‚ú® Processed intelligently by {BOT_NAME}",
        f"üìä Insight provided by {BOT_NAME}",
        f"üìö Report generated by {BOT_NAME}",
        f"üåê Analysis complete ‚Äî {BOT_NAME} signing off",
    ]
    return f"{prefix} {raw}\n\n{random.choice(closings)}"

# -----------------------------
# Cleanup
# -----------------------------
def cleanup_non_jarvis():
    if not jarvis_app_id: return
    try:
        url = f"{GOTIFY_URL}/message?token={CLIENT_TOKEN}"
        msgs = requests.get(url, timeout=5).json().get("messages", [])
        for msg in msgs:
            if msg.get("appid") != jarvis_app_id:
                delete_message(msg["id"])
    except: pass

def cleanup_old_jarvis():
    cutoff = time.time() - (12*3600)
    try:
        url = f"{GOTIFY_URL}/message?token={CLIENT_TOKEN}"
        msgs = requests.get(url, timeout=5).json().get("messages", [])
        for msg in msgs:
            ts = datetime.datetime.fromisoformat(msg["date"].replace("Z","+00:00")).timestamp()
            if ts < cutoff and msg.get("appid") == jarvis_app_id:
                delete_message(msg["id"])
    except: pass

# -----------------------------
# Radarr / Sonarr Functions
# -----------------------------
def get_radarr_movies():
    global radarr_cache
    if not RADARR_ENABLED: return []
    try:
        url = f"{RADARR_URL.rstrip('/')}/api/v3/movie?apikey={RADARR_API_KEY}"
        data = requests.get(url, timeout=10).json()
        radarr_cache = {m["id"]: m for m in data}
        return data
    except: return list(radarr_cache.values())

def get_sonarr_series():
    global sonarr_cache
    if not SONARR_ENABLED: return []
    try:
        url = f"{SONARR_URL.rstrip('/')}/api/v3/series?apikey={SONARR_API_KEY}"
        data = requests.get(url, timeout=10).json()
        sonarr_cache = {s["id"]: s for s in data}
        return data
    except: return list(sonarr_cache.values())

def get_upcoming_movies():
    try:
        url = f"{RADARR_URL.rstrip('/')}/api/v3/calendar?apikey={RADARR_API_KEY}"
        return requests.get(url, timeout=10).json()
    except: return []

def get_upcoming_episodes():
    try:
        url = f"{SONARR_URL.rstrip('/')}/api/v3/calendar?apikey={SONARR_API_KEY}"
        return requests.get(url, timeout=10).json()
    except: return []

# -----------------------------
# Weather (MET Norway API)
# -----------------------------
def get_weather():
    if not WEATHER_ENABLED: return "Weather disabled."
    try:
        url = f"https://api.met.no/weatherapi/locationforecast/2.0/compact?lat={WEATHER_LAT}&lon={WEATHER_LON}"
        r = requests.get(url, headers={"User-Agent":"JarvisBot/1.0"}, timeout=10).json()
        d = r["properties"]["timeseries"][0]["data"]["instant"]["details"]
        temp, wind = d["air_temperature"], d["wind_speed"]
        return f"üå§ Current weather: {temp}¬∞C, wind {wind} km/h"
    except Exception as e:
        return f"Weather fetch failed: {e}"

# -----------------------------
# Command Handler
# -----------------------------
def handle_command(msg):
    q = msg.lower()

    # Movies & Series Counts
    if "how many movies" in q or "movie count" in q:
        return f"üé¨ You have {len(get_radarr_movies())} movies."
    if "how many series" in q or "series count" in q:
        return f"üì∫ You have {len(get_sonarr_series())} series."

    # Longest / Shortest Movies
    if "longest movie" in q:
        movies = get_radarr_movies()
        if not movies: return "No movies found."
        m = max(movies, key=lambda x:x.get("runtime",0) or 0)
        return f"üé¨ Longest movie: {m['title']} ({m.get('runtime',0)} mins)"
    if "shortest movie" in q:
        movies = get_radarr_movies()
        if not movies: return "No movies found."
        m = min(movies, key=lambda x:x.get("runtime",9999) or 9999)
        return f"üé¨ Shortest movie: {m['title']} ({m.get('runtime',0)} mins)"

    # Largest / Longest Series
    if "largest series" in q or "most episodes" in q:
        series = get_sonarr_series()
        if not series: return "No series found."
        s = max(series, key=lambda x:x.get("episodeCount",0))
        return f"üì∫ Largest series: {s['title']} ({s.get('episodeCount',0)} episodes)"
    if "longest series" in q:
        series = get_sonarr_series()
        if not series: return "No series found."
        s = max(series, key=lambda x:x.get("seasonCount",0))
        return f"üì∫ Longest series: {s['title']} ({s.get('seasonCount',0)} seasons)"

    # Upcoming Movies / Series
    if "upcoming movies" in q:
        items = get_upcoming_movies()
        if not items: return "No upcoming movies this week."
        lines = [f"‚Ä¢ {m['title']} ({m['inCinemas'][:10]})" for m in items[:5]]
        return "üé¨ Upcoming movies:\n" + "\n".join(lines)
    if "upcoming series" in q or "upcoming shows" in q:
        items = get_upcoming_episodes()
        if not items: return "No upcoming episodes this week."
        lines = [f"‚Ä¢ {e['series']['title']} - S{e['seasonNumber']}E{e['episodeNumber']} ({e['airDate']})"
                 for e in items[:5] if e.get("series")]
        return "üì∫ Upcoming episodes:\n" + "\n".join(lines)

    # Weather
    if "weather" in q:
        return get_weather()

    # Help
    if "help" in q:
        return (
            "ü§ñ Commands:\n"
            "- Upcoming movies / series\n"
            "- Movie count / Series count\n"
            "- Longest / Shortest movie\n"
            "- Longest / Largest series\n"
            "- Weather\n"
        )

    return f"I didn‚Äôt understand. Try '{BOT_NAME} help' for commands."

# -----------------------------
# Scheduler
# -----------------------------
def run_scheduler():
    schedule.every(5).seconds.do(cleanup_non_jarvis)
    schedule.every(12).hours.do(cleanup_old_jarvis)
    while True:
        schedule.run_pending()
        time.sleep(1)

# -----------------------------
# Websocket Listener
# -----------------------------
async def listen():
    ws_url = GOTIFY_URL.replace("http://","ws://").replace("https://","wss://") + f"/stream?token={CLIENT_TOKEN}"
    async with websockets.connect(ws_url, ping_interval=30, ping_timeout=10) as ws:
        async for raw in ws:
            try:
                data = json.loads(raw)
                msg_id, appid, title, message = data["id"], data["appid"], data["title"], data["message"]

                if appid == jarvis_app_id: continue
                if not msg_id: continue

                resp = handle_command(message)
                if resp:
                    send_message("Command Response", beautify_message(resp))
                    delete_message(msg_id)

            except Exception as e:
                print(f"[{BOT_NAME}] WS error: {e}")

# -----------------------------
# Main
# -----------------------------
if __name__ == "__main__":
    resolve_app_id()
    send_message("Startup", f"üöÄ {BOT_NAME} systems online.", priority=5)

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.create_task(listen())
    loop.run_in_executor(None, run_scheduler)
    loop.run_forever()
