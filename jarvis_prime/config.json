#!/usr/bin/env python3
# /app/enviroguard.py
#
# EnviroGuard — ambient-aware LLM performance governor for Jarvis Prime
#
# Responsibilities:
# - Prefer Home Assistant indoor temperature; fallback to Open-Meteo outdoor
# - Decide a profile (off/ hot/ normal/ boost/ cold/ manual) using hysteresis to avoid flapping
# - Apply profile by updating the shared "merged" config + select env vars
# - OFF profile (or cpu_percent <= 0) hard-disables LLM/riffs to protect the host
#
# Public API expected by /app/bot.py:
#   - get_boot_status_line(merged: dict) -> str
#   - command(want: str, merged: dict) -> str
#   - run_forever(merged: dict) -> None

import os
import sys
import json
import time
import threading
import requests
from typing import Any, Dict, Optional

# -------------------------------------------------------------------
# Default fallback profiles — only used if options.json not provided
# -------------------------------------------------------------------
DEFAULT_PROFILES: Dict[str, Dict[str, Any]] = {
    "manual": {"cpu_percent": 80, "ctx_tokens": 4096, "timeout_seconds": 20},
    "hot":    {"cpu_percent": 50, "ctx_tokens": 2048, "timeout_seconds": 15},
    "normal": {"cpu_percent": 80, "ctx_tokens": 4096, "timeout_seconds": 20},
    "boost":  {"cpu_percent": 95, "ctx_tokens": 8192, "timeout_seconds": 25},
    "cold":   {"cpu_percent": 60, "ctx_tokens": 8192, "timeout_seconds": 25},
}

# -------------------------------------------------------------------
# Utility: load enviroguard profiles from options.json
# -------------------------------------------------------------------
def load_profiles(cfg: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
    """Load llm_enviroguard_profiles from config if present, else defaults."""
    raw = cfg.get("llm_enviroguard_profiles")
    if not raw:
        print("[EnviroGuard] No profiles in config → using defaults")
        return DEFAULT_PROFILES

    try:
        if isinstance(raw, str):
            parsed = json.loads(raw)
            if isinstance(parsed, dict):
                print("[EnviroGuard] Loaded profiles from config.json (string)")
                return parsed
        elif isinstance(raw, dict):
            print("[EnviroGuard] Loaded profiles from config.json (dict)")
            return raw
    except Exception as e:
        print(f"[EnviroGuard] Failed to parse profiles from config: {e}")

    print("[EnviroGuard] Falling back to defaults")
    return DEFAULT_PROFILES
# -------------------------------------------------------------------
# Temperature helpers
# -------------------------------------------------------------------

def fetch_ha_temp(cfg: Dict[str, Any]) -> Optional[float]:
    """Try to read temperature from Home Assistant sensor if enabled."""
    if not cfg.get("llm_enviroguard_ha_enabled"):
        return None

    base = cfg.get("llm_enviroguard_ha_base_url")
    token = cfg.get("llm_enviroguard_ha_token")
    entity = cfg.get("llm_enviroguard_ha_temp_entity")

    if not base or not token or not entity:
        return None

    try:
        url = f"{base}/api/states/{entity}"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        resp = requests.get(url, headers=headers, timeout=5)
        if resp.status_code == 200:
            data = resp.json()
            val = float(data["state"])
            return val
    except Exception as e:
        print(f"[EnviroGuard] Failed HA temp fetch: {e}")
    return None


def fetch_outdoor_temp(lat: float, lon: float) -> Optional[float]:
    """Fallback: outdoor temp via Open-Meteo."""
    try:
        url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current=temperature_2m"
        resp = requests.get(url, timeout=5)
        if resp.status_code == 200:
            data = resp.json()
            return float(data["current"]["temperature_2m"])
    except Exception as e:
        print(f"[EnviroGuard] Failed outdoor temp fetch: {e}")
    return None

# -------------------------------------------------------------------
# Profile decision logic
# -------------------------------------------------------------------

class ProfileDecider:
    def __init__(self, cfg: Dict[str, Any]):
        self.cfg = cfg
        self.last_profile: Optional[str] = None
        self.hysteresis = cfg.get("llm_enviroguard_hysteresis_c", 2)
        self.profiles = load_profiles(cfg)

    def pick(self, temp_c: Optional[float], manual: Optional[str]) -> str:
        """Return which profile to use (manual overrides auto)."""
        if manual and manual in self.profiles:
            return manual

        if temp_c is None:
            return "normal"

        # Thresholds
        off_c = self.cfg.get("llm_enviroguard_off_c", 42)
        hot_c = self.cfg.get("llm_enviroguard_hot_c", 30)
        norm_c = self.cfg.get("llm_enviroguard_normal_c", 22)
        boost_c = self.cfg.get("llm_enviroguard_boost_c", 16)
        cold_c = self.cfg.get("llm_enviroguard_cold_c", 10)

        prof = "normal"
        if temp_c >= off_c:
            prof = "off"
        elif temp_c >= hot_c:
            prof = "hot"
        elif temp_c >= norm_c:
            prof = "normal"
        elif temp_c >= boost_c:
            prof = "boost"
        elif temp_c <= cold_c:
            prof = "cold"

        # Hysteresis: if switching too fast, hold last
        if self.last_profile and self.last_profile != prof:
            if abs(temp_c - norm_c) < self.hysteresis:
                prof = self.last_profile

        self.last_profile = prof
        return prof
# -------------------------------------------------------------------
# Profile application
# -------------------------------------------------------------------

def apply_profile(cfg: Dict[str, Any], prof: str, profiles: Dict[str, Dict[str, Any]]) -> Dict[str, Any]:
    """Apply profile settings to merged config and environment variables."""
    merged = {}

    if prof not in profiles:
        print(f"[EnviroGuard] Profile '{prof}' not found, using 'normal'")
        prof = "normal"

    prof_cfg = profiles.get(prof, {})
    cpu = int(prof_cfg.get("cpu_percent", cfg.get("llm_max_cpu_percent", 50)))
    ctx = int(prof_cfg.get("ctx_tokens", cfg.get("llm_ctx_tokens", 4096)))
    to = int(prof_cfg.get("timeout_seconds", cfg.get("llm_timeout_seconds", 60)))

    merged["llm_max_cpu_percent"] = cpu
    merged["llm_ctx_tokens"] = ctx
    merged["llm_timeout_seconds"] = to
    merged["active_enviroguard_profile"] = prof

    # Export as env vars for llama.cpp workers
    os.environ["LLM_MAX_CPU_PERCENT"] = str(cpu)
    os.environ["LLM_CTX_TOKENS"] = str(ctx)
    os.environ["LLM_TIMEOUT_SECONDS"] = str(to)
    os.environ["LLM_ACTIVE_PROFILE"] = prof

    print(f"[EnviroGuard] Applied profile={prof} (CPU={cpu}%, ctx={ctx}, to={to}s)")
    return merged


# -------------------------------------------------------------------
# Notification helpers
# -------------------------------------------------------------------

def notify_profile_change(cfg: Dict[str, Any], prof: str, merged: Dict[str, Any], manual: Optional[str]) -> None:
    """Send profile change update to Gotify and Inbox."""
    msg = f"Update: resynced. balanced. ⚙️\n"
    if manual:
        msg += f"Manual override → profile **{prof.upper()}** (CPU={merged['llm_max_cpu_percent']}%, ctx={merged['llm_ctx_tokens']}, to={merged['llm_timeout_seconds']}s)"
    else:
        msg += f"Auto mode → profile **{prof.upper()}** (CPU={merged['llm_max_cpu_percent']}%, ctx={merged['llm_ctx_tokens']}, to={merged['llm_timeout_seconds']}s)"

    print(f"[EnviroGuard] Notify: {msg.replace(chr(10),' ')}")

    # Gotify push
    if cfg.get("push_gotify_enabled") and cfg.get("gotify_url") and cfg.get("gotify_app_token"):
        try:
            requests.post(
                f"{cfg['gotify_url']}/message",
                headers={"X-Gotify-Key": cfg["gotify_app_token"]},
                json={"title": "🌡️ EnviroGuard", "message": msg, "priority": 5},
                timeout=5,
            )
        except Exception as e:
            print(f"[EnviroGuard] Gotify notify failed: {e}")

    # Inbox push (via shared file for bot.py to ingest)
    try:
        inbox_path = "/share/jarvis_prime/inbox/enviroguard.txt"
        os.makedirs(os.path.dirname(inbox_path), exist_ok=True)
        with open(inbox_path, "w") as f:
            f.write(msg)
    except Exception as e:
        print(f"[EnviroGuard] Failed to write inbox note: {e}")
# -------------------------------------------------------------------
# Main loop
# -------------------------------------------------------------------

def run_loop(cfg: Dict[str, Any], stop_event: threading.Event) -> None:
    """Main EnviroGuard loop that polls temperature, decides profile, and applies it."""
    profiles = load_profiles(cfg)
    poll_mins = int(cfg.get("llm_enviroguard_poll_minutes", 30))
    hyst = int(cfg.get("llm_enviroguard_hysteresis_c", 2))

    last_prof: Optional[str] = None
    manual_override: Optional[str] = None

    print(f"[EnviroGuard] Starting loop (poll={poll_mins}m, hyst={hyst}°C)")

    while not stop_event.is_set():
        try:
            temp = get_temperature(cfg)
            prof = decide_profile(cfg, temp, hyst)

            # Check for manual override request
            man_prof = os.environ.get("LLM_MANUAL_PROFILE")
            if man_prof and man_prof.lower() in profiles:
                prof = man_prof.lower()
                manual_override = prof
            else:
                manual_override = None

            # Apply if changed
            if prof != last_prof:
                merged = apply_profile(cfg, prof, profiles)
                notify_profile_change(cfg, prof, merged, manual_override)
                last_prof = prof

        except Exception as e:
            print(f"[EnviroGuard] Loop error: {e}")

        stop_event.wait(poll_mins * 60)
# -------------------------------------------------------------------
# Startup helpers
# -------------------------------------------------------------------

def boot_status_line(cfg: Dict[str, Any]) -> str:
    """Return a one-liner status for bot.py boot logging."""
    profiles = load_profiles(cfg)
    cur = os.environ.get("LLM_MANUAL_PROFILE") or "auto"
    prof = cur.lower()
    prof_cfg = profiles.get(prof, {})

    if prof == "auto":
        return f"🌡️ EnviroGuard — AUTO mode active (using thresholds)"
    return (f"🌡️ EnviroGuard — MANUAL profile={prof.upper()} "
            f"(CPU={prof_cfg.get('cpu_percent','?')}%, "
            f"ctx={prof_cfg.get('ctx_tokens','?')}, "
            f"to={prof_cfg.get('timeout_seconds','?')}s)")

def start_background(cfg: Dict[str, Any]) -> None:
    """Start EnviroGuard background thread."""
    global _thread, _stop
    if _thread and _thread.is_alive():
        print("[EnviroGuard] Already running")
        return
    _stop = threading.Event()
    _thread = threading.Thread(
        target=run_loop, args=(cfg, _stop), daemon=True
    )
    _thread.start()
    print("[EnviroGuard] Background loop started")

def stop_background() -> None:
    """Stop EnviroGuard background thread."""
    global _thread, _stop
    if _stop:
        _stop.set()
    if _thread:
        try:
            _thread.join(timeout=5)
        except Exception:
            pass
    _thread = None
    _stop = None
    print("[EnviroGuard] Background loop stopped")


# -------------------------------------------------------------------
# Init state
# -------------------------------------------------------------------
_thread: Optional[threading.Thread] = None
_stop: Optional[threading.Event] = None